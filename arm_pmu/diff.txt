diff --git a/drivers/perf/arm_pmu.c b/drivers/perf/arm_pmu.c
index 57d20cf3d..8b3de184d 100644
--- a/drivers/perf/arm_pmu.c
+++ b/drivers/perf/arm_pmu.c
@@ -26,6 +26,26 @@
 
 #include <asm/irq_regs.h>
 
+/*
+ * ADDED by Lien Zhu
+ * January 31, 2023
+ */
+#define MAX_TIME_READS 100
+#define CPU_CORE_OF_INTEREST 1 // only store elapsed time if the event was scheduled on this CPU core
+
+#include <linux/time.h>
+#include <linux/smp.h>
+
+static ktime_t perf_start_time;
+static ktime_t perf_end_time;
+
+struct timespec64 kt;
+static struct timespec64 kt_arr[MAX_TIME_READS]; // this might not be working either
+static int kt_arr_iterator = 0; // this value needs to persist through the kernel process
+/*
+ * END ADDED
+ */
+
 static int armpmu_count_irq_users(const int irq);
 
 struct pmu_irq_ops {
@@ -314,6 +334,31 @@ armpmu_del(struct perf_event *event, int flags)
 	int idx = hwc->idx;
 
 	armpmu_stop(event, PERF_EF_UPDATE);
+
+	/*
+	 * ADDED by Lien Zhu
+	 * January 31, 2023
+	 * Ending ktime_get() invocation 
+	 */
+	perf_end_time = ktime_get();
+	kt = ktime_to_timespec64( ktime_sub(perf_end_time, perf_start_time) );
+	if (kt_arr_iterator < MAX_TIME_READS && smp_processor_id() == CPU_CORE_OF_INTEREST) {
+		kt_arr[kt_arr_iterator] = kt;
+		++kt_arr_iterator;
+	}
+	if (kt_arr_iterator == MAX_TIME_READS) { // only do this when kt_arr_iterator == MAX_TIME_READS otherwise it will repeat
+		int t;
+		for (t = 0; t < MAX_TIME_READS; ++t) {
+			kt = kt_arr[t];
+			printk(KERN_INFO "Index: %d,\tElapsed time: %lld \tsec,\t%09ld\tnanoseconds \n", t, kt.tv_sec, kt.tv_nsec);
+		}	
+		kt_arr_iterator = MAX_TIME_READS + 1; // Force the iterator variable to exceed the MAX_TIME_READS bound
+	}
+	/*
+	 * END ADDED
+	 */
+
+
 	hw_events->events[idx] = NULL;
 	armpmu->clear_event_idx(hw_events, event);
 	perf_event_update_userpage(event);
@@ -347,8 +392,21 @@ armpmu_add(struct perf_event *event, int flags)
 	hw_events->events[idx] = event;
 
 	hwc->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;
-	if (flags & PERF_EF_START)
+
+	if (flags & PERF_EF_START) {
+
+		/*
+		 * ADDED by Lien Zhu 
+		 * January 31, 2023
+		 * Starts ktime_get() invocation
+		 */
+		perf_start_time = ktime_get();
+		/*
+		 * END ADDED
+		 */
+
 		armpmu_start(event, PERF_EF_RELOAD);
+	}
 
 	/* Propagate our changes to the userspace mapping. */
 	perf_event_update_userpage(event);
